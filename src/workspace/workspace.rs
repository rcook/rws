use crate::config::{ConfigHash, ConfigObject};
use crate::error::{user_error, user_error_result, Result};
use crate::scripting::command::Command;

use std::collections::HashSet;
use std::env;
use std::path::{Path, PathBuf};

const WORKSPACE_CONFIG_FILE_NAME: &str = "rws-workspace.yaml";

mod config_helper {
    use crate::config::{ConfigArray, ConfigHash};
    use crate::error::{user_error_result, Result};

    pub fn convert_optional_array<T, F>(hash: &ConfigHash, key: &str, f: F) -> Result<Option<T>>
    where
        F: FnOnce(ConfigArray) -> Result<T>,
    {
        match hash.get(key) {
            Some(obj) => match obj.into_vec() {
                Some(v) => f(v).map(|result| Some(result)),
                None => user_error_result(format!(
                    "Configuration item \"{}\" is not in expected format",
                    key
                )),
            },
            None => Ok(None),
        }
    }

    pub fn convert_optional_hash<T, F>(hash: &ConfigHash, key: &str, f: F) -> Result<Option<T>>
    where
        F: FnOnce(ConfigHash) -> Result<T>,
    {
        match hash.get(key) {
            Some(obj) => match obj.into_hash() {
                Some(h) => f(h).map(|result| Some(result)),
                None => user_error_result(format!(
                    "Configuration item \"{}\" is not in expected format",
                    key
                )),
            },
            None => Ok(None),
        }
    }
}

/// Source of dependency information
pub enum DependencySource {
    /// Dependencies specified in configuration file
    Hash(ConfigHash),
    /// Dependencies generated by external script command
    Command(Command),
    /// No dependency information provided
    None,
}

/// Workspace information derived from file system and configuration file
pub struct Workspace {
    /// Workspace directory
    pub workspace_dir: PathBuf,
    /// Configuration path
    pub config_path: Option<PathBuf>,
    /// Excluded project directories
    pub excluded_project_dirs: HashSet<PathBuf>,
    /// Source of dependency information
    pub dependency_source: DependencySource,
    /// Workspace initialization command
    pub init_command: Option<Command>,
}

impl Workspace {
    /// Constructor
    pub fn new(workspace_dir: Option<PathBuf>, config_path: Option<PathBuf>) -> Result<Self> {
        match (workspace_dir, config_path) {
            (Some(d), Some(c)) => Self::known(d, Some(c)),
            (Some(d), None) => {
                let p = d.join(WORKSPACE_CONFIG_FILE_NAME);
                Self::known(d, if p.exists() { Some(p) } else { None })
            }
            (None, Some(c)) => Self::known(
                c.parent()
                    .ok_or_else(|| user_error("Invalid config path"))?
                    .to_path_buf(),
                Some(c),
            ),
            (None, None) => Self::find(&env::current_dir()?),
        }
    }

    fn known(workspace_dir: PathBuf, config_path: Option<PathBuf>) -> Result<Self> {
        match &config_path {
            Some(c) => match ConfigObject::read_config_file(&c)? {
                Some(config) => Self::read_config(workspace_dir, c.to_path_buf(), config),
                None => Ok(Self {
                    workspace_dir: workspace_dir,
                    config_path: config_path,
                    excluded_project_dirs: HashSet::new(),
                    dependency_source: DependencySource::None,
                    init_command: None,
                }),
            },
            None => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: config_path,
                excluded_project_dirs: HashSet::new(),
                dependency_source: DependencySource::None,
                init_command: None,
            }),
        }
    }

    fn find(search_dir: &Path) -> Result<Self> {
        let mut p = search_dir;
        loop {
            let config_path = p.join(WORKSPACE_CONFIG_FILE_NAME);
            if config_path.exists() {
                match ConfigObject::read_config_file(&config_path)? {
                    Some(config) => return Self::read_config(p.to_path_buf(), config_path, config),
                    None => {
                        return Ok(Self {
                            workspace_dir: p.to_path_buf(),
                            config_path: Some(config_path),
                            excluded_project_dirs: HashSet::new(),
                            dependency_source: DependencySource::None,
                            init_command: None,
                        })
                    }
                }
            }
            match p.parent() {
                Some(parent) => p = parent,
                None => {
                    return Ok(Self {
                        workspace_dir: search_dir.to_path_buf(),
                        config_path: None,
                        excluded_project_dirs: HashSet::new(),
                        dependency_source: DependencySource::None,
                        init_command: None,
                    })
                }
            }
        }
    }

    fn read_config(
        workspace_dir: PathBuf,
        config_path: PathBuf,
        config_object: ConfigObject,
    ) -> Result<Self> {
        use crate::config_key::*;
        use config_helper::*;

        let root_hash = config_object
            .into_hash()
            .ok_or_else(|| user_error("Invalid config hash"))?;

        let excluded_project_dirs: HashSet<PathBuf> =
            convert_optional_array(&root_hash, EXCLUDED_PROJECTS, |array| {
                let mut values: Vec<PathBuf> = Vec::new();
                for i in 0..array.len() {
                    let obj = array.get(i);
                    let value = obj.as_str().ok_or_else(|| {
                        user_error(format!(
                            "Invalid value encountered in \"{}\" configuration element",
                            EXCLUDED_PROJECTS
                        ))
                    })?;
                    values.push(workspace_dir.join(value))
                }
                Ok(values.into_iter().collect::<HashSet<PathBuf>>())
            })?
            .unwrap_or_else(|| HashSet::new());

        let init_command =
            convert_optional_hash(&root_hash, INIT_COMMAND, |h| Command::new(&root_hash, &h))?;

        let dependencies = convert_optional_hash(&root_hash, DEPENDENCIES, |h| Ok(h))?;

        let dependency_command = convert_optional_hash(&root_hash, DEPENDENCY_COMMAND, |h| {
            Command::new(&root_hash, &h)
        })?;

        match (dependencies, dependency_command) {
            (Some(_), Some(_)) => user_error_result(format!(
                "Must specify at most one of \"{}\" and \"{}\" in workspace configuration",
                DEPENDENCIES, DEPENDENCY_COMMAND
            )),
            (Some(h), None) => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs: excluded_project_dirs,
                dependency_source: DependencySource::Hash(h),
                init_command: init_command,
            }),
            (None, Some(c)) => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs: excluded_project_dirs,
                dependency_source: DependencySource::Command(c),
                init_command: init_command,
            }),
            (None, None) => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs: excluded_project_dirs,
                dependency_source: DependencySource::None,
                init_command: init_command,
            }),
        }
    }
}
