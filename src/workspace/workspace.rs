use crate::config::{Config, ConfigHash};
use crate::error::{user_error, user_error_result, Result};
use crate::scripting::command::Command;

use super::config_cache::ConfigCache;

use std::collections::HashSet;
use std::env;
use std::path::{Path, PathBuf};

const WORKSPACE_CONFIG_FILE_NAME: &str = "rws-workspace.yaml";

/// Source of dependency information
pub enum DependencySource<'a> {
    /// Dependencies specified in configuration file
    Hash(ConfigHash<'a>),
    /// Dependencies generated by external script command
    Command(Command),
    /// No dependency information provided
    None,
}

/// Workspace information derived from file system and configuration file
pub struct Workspace<'a> {
    /// Workspace directory
    pub workspace_dir: PathBuf,
    /// Configuration path
    pub config_path: Option<PathBuf>,
    /// Excluded project directories
    pub excluded_project_dirs: HashSet<PathBuf>,
    /// Source of dependency information
    pub dependency_source: DependencySource<'a>,
    /// Workspace initialization command
    pub init_command: Option<Command>,
}

impl<'a> Workspace<'a> {
    /// Constructor
    pub fn new(
        config_cache: &'a mut ConfigCache,
        workspace_dir: Option<PathBuf>,
        config_path: Option<PathBuf>,
    ) -> Result<Self> {
        match (workspace_dir, config_path) {
            (Some(d), Some(c)) => Self::known(config_cache, d, Some(c)),
            (Some(d), None) => {
                let p = d.join(WORKSPACE_CONFIG_FILE_NAME);
                Self::known(config_cache, d, if p.exists() { Some(p) } else { None })
            }
            (None, Some(c)) => Self::known(
                config_cache,
                c.parent()
                    .ok_or_else(|| user_error("Invalid config path"))?
                    .to_path_buf(),
                Some(c),
            ),
            (None, None) => Self::find(config_cache, &env::current_dir()?),
        }
    }

    fn known(
        config_cache: &'a mut ConfigCache,
        workspace_dir: PathBuf,
        config_path: Option<PathBuf>,
    ) -> Result<Self> {
        match &config_path {
            Some(c) => match config_cache.get_config(&c)? {
                Some(config) => Self::read_config(workspace_dir, c.to_path_buf(), &config),
                None => Ok(Self {
                    workspace_dir: workspace_dir,
                    config_path: config_path,
                    excluded_project_dirs: HashSet::new(),
                    dependency_source: DependencySource::None,
                    init_command: None,
                }),
            },
            None => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: config_path,
                excluded_project_dirs: HashSet::new(),
                dependency_source: DependencySource::None,
                init_command: None,
            }),
        }
    }

    fn find(config_cache: &'a mut ConfigCache, search_dir: &Path) -> Result<Self> {
        let mut p = search_dir;
        loop {
            let config_path = p.join(WORKSPACE_CONFIG_FILE_NAME);
            if config_path.exists() {
                match config_cache.get_config(&config_path)? {
                    Some(config) => {
                        return Self::read_config(p.to_path_buf(), config_path, &config)
                    }
                    None => {
                        return Ok(Self {
                            workspace_dir: p.to_path_buf(),
                            config_path: Some(config_path),
                            excluded_project_dirs: HashSet::new(),
                            dependency_source: DependencySource::None,
                            init_command: None,
                        })
                    }
                }
            }
            match p.parent() {
                Some(parent) => p = parent,
                None => {
                    return Ok(Self {
                        workspace_dir: search_dir.to_path_buf(),
                        config_path: None,
                        excluded_project_dirs: HashSet::new(),
                        dependency_source: DependencySource::None,
                        init_command: None,
                    })
                }
            }
        }
    }

    fn read_config(
        workspace_dir: PathBuf,
        config_path: PathBuf,
        config: &'a Config,
    ) -> Result<Self> {
        let root_hash = config
            .as_hash()
            .ok_or_else(|| user_error("Invalid config hash"))?;
        let excluded_project_dirs = root_hash
            .as_str_vec("excluded-projects")
            .unwrap_or_else(|| Vec::new())
            .into_iter()
            .map(|x| workspace_dir.join(x))
            .collect::<HashSet<_>>();
        let dependencies_hash_opt = root_hash.as_hash("dependencies");
        let dependency_command_hash_opt = root_hash.as_hash("dependency-command");
        let init_command = match root_hash.as_hash("init-command") {
            Some(h) => Some(Command::new(&root_hash, &h)?),
            None => None,
        };

        match (dependencies_hash_opt, &dependency_command_hash_opt) {
            (Some(_), Some(_)) => user_error_result("Must specify at most one of \"dependencies\" and \"dependency-command\" in workspace configuration"),
            (Some(dependencies_hash), None) => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs: excluded_project_dirs,
                dependency_source: DependencySource::Hash(dependencies_hash),
                init_command:init_command
            }),
            (None, Some(dependency_command_hash)) => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs: excluded_project_dirs,
                dependency_source: DependencySource::Command(Command::new(&root_hash, dependency_command_hash)?),
                init_command:init_command
            }),
            (None, None) => Ok(Self {
                workspace_dir: workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs: excluded_project_dirs,
                dependency_source: DependencySource::None,
                init_command:init_command
            })
        }
    }
}
