// The MIT License (MIT)
//
// Copyright (c) 2020-3 Richard Cook
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
use crate::config::{ConfigHash, ConfigObject};
use crate::scripting::ScriptCommand;
use anyhow::{anyhow, bail, Result};
use std::collections::HashSet;
use std::env;
use std::path::{Path, PathBuf};

const WORKSPACE_CONFIG_FILE_NAME: &str = "rws-workspace.yaml";

mod config_helper {
    use crate::config::{ConfigArray, ConfigHash};
    use anyhow::{bail, Result};

    pub fn convert_optional_array<T, F>(hash: &ConfigHash, key: &str, f: F) -> Result<Option<T>>
    where
        F: FnOnce(ConfigArray) -> Result<T>,
    {
        match hash.get(key) {
            Some(obj) => match obj.into_vec() {
                Some(v) => f(v).map(Some),
                None => bail!("Configuration item \"{}\" is not in expected format", key),
            },
            None => Ok(None),
        }
    }

    pub fn convert_optional_hash<T, F>(hash: &ConfigHash, key: &str, f: F) -> Result<Option<T>>
    where
        F: FnOnce(ConfigHash) -> Result<T>,
    {
        match hash.get(key) {
            Some(obj) => match obj.into_hash() {
                Some(h) => f(h).map(Some),
                None => bail!("Configuration item \"{}\" is not in expected format", key),
            },
            None => Ok(None),
        }
    }
}

/// Source of dependency information
#[derive(Debug)]
pub enum DependencySource {
    /// Dependencies specified in configuration file
    Hash(ConfigHash),
    /// Dependencies generated by external script command
    ScriptCommand(ScriptCommand),
    /// No dependency information provided
    None,
}

/// Workspace information derived from file system and configuration file
#[derive(Debug)]
pub struct Workspace {
    /// Workspace directory
    pub workspace_dir: PathBuf,
    /// Configuration path
    pub config_path: Option<PathBuf>,
    /// Excluded project directories
    pub excluded_project_dirs: HashSet<PathBuf>,
    /// Source of dependency information
    pub dependency_source: DependencySource,
    /// Workspace initialization command
    pub init_command: Option<ScriptCommand>,
}

impl Workspace {
    /// Constructor
    pub fn new(workspace_dir: Option<PathBuf>, config_path: Option<PathBuf>) -> Result<Self> {
        match (workspace_dir, config_path) {
            (Some(d), Some(c)) => Self::known(d, Some(c)),
            (Some(d), None) => {
                let p = d.join(WORKSPACE_CONFIG_FILE_NAME);
                Self::known(d, if p.exists() { Some(p) } else { None })
            }
            (None, Some(c)) => Self::known(
                c.parent()
                    .ok_or_else(|| anyhow!("Invalid config path"))?
                    .to_path_buf(),
                Some(c),
            ),
            (None, None) => Self::find(&env::current_dir()?),
        }
    }

    fn known(workspace_dir: PathBuf, config_path: Option<PathBuf>) -> Result<Self> {
        match &config_path {
            Some(c) => match ConfigObject::read_config_file(c)? {
                Some(config) => Self::read_config(workspace_dir, c.to_path_buf(), config),
                None => Ok(Self {
                    workspace_dir,
                    config_path,
                    excluded_project_dirs: HashSet::new(),
                    dependency_source: DependencySource::None,
                    init_command: None,
                }),
            },
            None => Ok(Self {
                workspace_dir,
                config_path,
                excluded_project_dirs: HashSet::new(),
                dependency_source: DependencySource::None,
                init_command: None,
            }),
        }
    }

    fn find(search_dir: &Path) -> Result<Self> {
        let mut p = search_dir;
        loop {
            let config_path = p.join(WORKSPACE_CONFIG_FILE_NAME);
            if config_path.exists() {
                match ConfigObject::read_config_file(&config_path)? {
                    Some(config) => return Self::read_config(p.to_path_buf(), config_path, config),
                    None => {
                        return Ok(Self {
                            workspace_dir: p.to_path_buf(),
                            config_path: Some(config_path),
                            excluded_project_dirs: HashSet::new(),
                            dependency_source: DependencySource::None,
                            init_command: None,
                        })
                    }
                }
            }
            match p.parent() {
                Some(parent) => p = parent,
                None => {
                    return Ok(Self {
                        workspace_dir: search_dir.to_path_buf(),
                        config_path: None,
                        excluded_project_dirs: HashSet::new(),
                        dependency_source: DependencySource::None,
                        init_command: None,
                    })
                }
            }
        }
    }

    fn read_config(
        workspace_dir: PathBuf,
        config_path: PathBuf,
        config_object: ConfigObject,
    ) -> Result<Self> {
        use crate::config_key::*;
        use config_helper::*;

        let root_hash = config_object
            .into_hash()
            .ok_or_else(|| anyhow!("Invalid config hash"))?;

        let excluded_project_dirs: HashSet<PathBuf> =
            convert_optional_array(&root_hash, EXCLUDED_PROJECTS, |array| {
                let mut values: Vec<PathBuf> = Vec::new();
                for i in 0..array.len() {
                    let obj = array.get(i);
                    let value = obj.as_str().ok_or_else(|| {
                        anyhow!(format!(
                            "Invalid value encountered in \"{}\" configuration element",
                            EXCLUDED_PROJECTS
                        ))
                    })?;
                    values.push(workspace_dir.join(value))
                }
                Ok(values.into_iter().collect::<HashSet<PathBuf>>())
            })?
            .unwrap_or_default();

        let init_command = convert_optional_hash(&root_hash, INIT_COMMAND, |h| {
            ScriptCommand::new(&root_hash, &h)
        })?;

        let dependencies = convert_optional_hash(&root_hash, DEPENDENCIES, Ok)?;

        let dependency_command = convert_optional_hash(&root_hash, DEPENDENCY_COMMAND, |h| {
            ScriptCommand::new(&root_hash, &h)
        })?;

        match (dependencies, dependency_command) {
            (Some(_), Some(_)) => bail!(
                "Must specify at most one of \"{}\" and \"{}\" in workspace configuration",
                DEPENDENCIES,
                DEPENDENCY_COMMAND
            ),
            (Some(h), None) => Ok(Self {
                workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs,
                dependency_source: DependencySource::Hash(h),
                init_command,
            }),
            (None, Some(c)) => Ok(Self {
                workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs,
                dependency_source: DependencySource::ScriptCommand(c),
                init_command,
            }),
            (None, None) => Ok(Self {
                workspace_dir,
                config_path: Some(config_path),
                excluded_project_dirs,
                dependency_source: DependencySource::None,
                init_command,
            }),
        }
    }
}
